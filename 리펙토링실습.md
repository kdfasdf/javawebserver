## 개요
학부생 때 산학공동 프로젝트를 하면서 스프링 프레임워크를 사용하여 crud 기능을 구현할 때 별로 복잡하지 않은 로직임에도 불과하고 코드가 다소 더러워지는 것을 느꼈다.<br>
 그 당시 리펙토링에 대한 필요성을 느꼈는데(사실 막연하게 필요성을 느낀거지 나느 아직 단위 테스트
리펙토링에 대해서 잘 모른다) 막상 찍먹 해보려고 하니 test 폴더에 테스트 코드를 만들어서 하는 방식이 잘 와닿지 않아서 다음에 공부해야지 하고 넘어갔었다.<br>
그리고 이번 요구사항에서 자바 문법만으로 웹서버 기능을 구현 했는데 이전에 산학공동프로젝트를 했을 때 보다손댈 수 있는 곳이 많아 보였다.
<br><br>

이전 요구사항들을 구현하면서 스스로 코드가 아주 더러워 지는 것을 느꼈다.  POST로 회원가입 하기부터 그리 어려운 로직이 아님에도 불구하고 구현하면서 헷갈리다는 생각이 많이 들었다. 
코드가 복잡해졌던 이유를 스스로 생각해보자면 중복 요소가 있는 메서드로 뺴내지 않은점, 특정 기능을 처리하는 로직을 클래스로 분리하지 않은 것이 이유였다.
이번 리펙토링은 처음 하는 리펙토링인만큼 책을 따라가면서 진행한다.<br> 
내가 직접 고민해서 하는 것도 좋은 방법이지만 나는 아직 리펙토링에 대한 경험이 없다. <br><br>

우리가 학교에서 처음 알고리즘을 공부할 때 학교 과제가지고 몇 시간동안 고민해가면서 짠 경험이 있을 것 이다. 실력을 늘리기에 굉장히 좋은 방법이지만 처음 짠 알고리즘 코드를 기반으로 온라인 저지 문제를 풀어보면 다익스트라나 bfs dfs 문제에서 시간초과가 날 것이다.<br>
이는 내가 심사숙고해서 짠 알고리즘이 기본 예제 동작은 하지만 예외 케이스를 정답으로 처리할 만큼 올바른 알고리즘이 아니었을 확률이 있고 알고리즘을 구현하기 위해 활용한 자료구조 혹은 입출력이 그 알고리즘의 시간복잡도를 줄이기에 최적화된 자료구조, 입출력이 아닐 수도 있다.<br>
필자는 이에 대해 다른사람이 짠 상당히 깔끔한 알고리즘의 로직을 학습하고 코드를 잊었다. 그러면서 추가적으로 문제를 풀면서 더 최적화 시킬 수 있는 부분은 없는지 고민하면서 조금씩 더 좋은(간략한,빠른? 무슨 단어로 집어말하기는 애매하다) 알고리즘 코드로 개선해나가는 중이다.<br>
<br>

리펙토링도 마찬가지라고 생각한다. <br>
나는 아직 리펙토링에 대한 경험이 없다. 따라서 리펙토링을 진행할 때 막연하게 '여기는 중복일 것 같으니 클래스로 분리하자' 같은 생각은 할 수 있지만 '빼낸 클래스간에 필연적으로 생기는 결합성을 어느정도로 하는게 적당할까' 와 같은 주관을 가지고 있지 않기 때문이다.
이 세상엔 나보다 고수가 많고 맛봐야할 좋은코드가 많다.

<br>
<br>

<br>

- 헤더 읽는 부분에서의 중복
아래 코드는 내가 문제점을 느낀 실제 코드 부분인데 
스레드클래스를 상속한 RequestHandler 클래스 run 메서드 안에 일부분인데 if 문 안쪽과 else문 안쪽이 거의 유사하고
run 메서드 안에 저 코드를 적어놓아서 가독성이 굉장히 떨어진다.
- RequestHandler.java
```
            if (Files.exists( Paths.get("./webapp"+requestPath))){ //요청한 웹페이지에 해당하는 파일이 있다면
                byte[] body = Files.readAllBytes(new File("./webapp"+requestPath).toPath());
                //자기 전에 넣은거라 확인 필요
                while(!line.equals("")){
                    line=br.readLine();
                    if(line.contains("Cookie")){
                        cookie=Boolean.parseBoolean(HttpRequestUtils.parseCookies(line.split(":")[1]).get("logined"));
                        log.debug("{} \n{} Cookie:{}",line,HttpRequestUtils.parseCookies(line.split(":")[1]).get("logined"),cookie);
                    }
                }
                //

                urlFunction(requestPath,dos,params,body,cookie);    //웹 url에 따라 다른 기능을 수행하기 위함
            }
            else{                                         //없는 경우 기본 페이지인 index.html 페이지를 응답으로 보낸다
                log.debug("defaultPath{}",defaultPath);
                byte[] body = Files.readAllBytes(new File("./webapp"+defaultPath).toPath());
                //post 요청 body 읽기;
                int contentLength=0;            //로그인 쿠키 확인
                while(!line.equals("")){
                    line=br.readLine();
                    if(line.contains("Content-Length")){
                        contentLength = getContentLength(line);
                    }
                }
                String user = IOUtils.readData(br,contentLength);
                //post 요청 body 읽기
                urlFunction(requestPath, dos, user, body,cookie);
            }
```


우선 요청 메시지 헤더를 읽는 코드에서 중복이 많으니 해당 코드들을 HttpResponse 클래스로 분리해보겠다.
서버를 돌리지 않는 상태에서 테스트를 하는 것이므로 Http 메서드 GET 방식 헤더를 가지는 txt 파일과 POST 방식의 헤더를
가지는 txt 파일을 만들어준다

- Http_GET.txt
```
GET /user /create?userID=testcode&password=password&name=name HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: */*
```

- Http_POST.txt
```
POST /user /create HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: */*

userID=testcode&password=password&name=name
```

RequestHandler.java에서 요청 헤더를 읽어들이는 부분을 HttpRequest.java로 뽑아내고 이에대한 테스트 코드를 작성한다.
- HttpRequestTest.java
```
import org.junit.Test;

public class HttpRequestTest{
    private String testDirectory = "./src/test/resources/";
    @Test
    public void requestGet() throws Exception{
        InputStream in = new FileInputStream(new File(testDirectory+"Http_GET.txt"));
        HttpRequest request = new HttpRequest(in);
        assertEquals("GET",request.getMethod());
        assertEquals("/user/create".request.getPath());
        assertEquals("jeep-alive",request.Header("Connection"));
        assertEquals("testcode",request.getParameter(userId);
    }
    @Test
    public void request_POST() throws Exception{
        InputStream in = new FileInputStream(new File(testDirectory+"Http_POST.txt"));
        HttpRequest request = new HttpRequest(in);
        assertEquals("POST",request.getMethod());
        assertEquals("/user/create",request.getPath());
        assertEquals("keep-alive",request.getHeader("Connection"));
        assertEquals("name",request.getParameter)
    }
}
```

응답 데이터를 처리하는 로직을 별도의 클래스로 분리한다(HttpResponse)
- HttpResponseTest.Java
```

```
