## 개요
학부생 때 산학공동 프로젝트를 하면서 스프링 프레임워크를 사용하여 crud 기능을 구현할 때 별로 복잡하지 않은 로직인데 코드가 다소 더러워지는 것을 느꼈다. 그 당시 리펙토링에 대한 필요성을 느꼈는데(사실 막연하게 필요성을 느낀거지 나느 아직 단위 테스트
리펙토링에 대해서 잘 모른다) 막상 찍먹 해보려고 하니 test 폴더에 테스트 코드를 만들어서 하는 방식이 잘 와닿지 않아서 다음에 공부해야지 하고 넘어갔었다.<br>
요구사항은 자바 문법만으로 웹서버 기능을 구현 했는데 이전에 산학공동프로젝트를 했을 때 보다손댈 수 있는 곳이 많아 보였다.
이전 요구사항들을 구현하면서 스스로 코드가 아주 더러워 지는 것을 느꼈다.  POST로 회원가입 하기부터 그리 어려운 로직이 아님에도 불구하고 구현하면서 헷갈리다는 생각이 많이 들었다. 
코드가 복잡해졌던 이유를 스스로 생각해보자면 중복 요소가 있는 메서드로 뺴내지 않은점, 특정 기능을 처리하는 로직을 클래스로 분리하지 않은 것이 이유였다.
리펙토링은 책에서 제안하는 방법으로 테스트 코드를 짜면서 진행된다. 테스트 코드 역시 현업에서 중요하게 다뤄지는데에 비해 학부생 때는 생각해보기 힘든 부분이었다.
이 기회에 테스트 코드를 통한 리펙토링을 간단하게 진행해보겠다.

<br>

아래 코드는 내가 문제점을 느낀 실제 코드 부분인데 
스레드클래스를 상속한 RequestHandler 클래스 run 메서드 안에 일부분인데 if 문 안쪽과 else문 안쪽이 거의 유사하고
run 메서드 안에 저 코드를 적어놓아서 가독성이 굉장히 떨어진다.
- RequestHandler.java
```
            if (Files.exists( Paths.get("./webapp"+requestPath))){ //요청한 웹페이지에 해당하는 파일이 있다면
                byte[] body = Files.readAllBytes(new File("./webapp"+requestPath).toPath());
                //자기 전에 넣은거라 확인 ㅣㄹ요
                while(!line.equals("")){
                    line=br.readLine();
                    if(line.contains("Cookie")){
                        cookie=Boolean.parseBoolean(HttpRequestUtils.parseCookies(line.split(":")[1]).get("logined"));
                        log.debug("{} \n{} Cookie:{}",line,HttpRequestUtils.parseCookies(line.split(":")[1]).get("logined"),cookie);
                    }
                }
                //

                urlFunction(requestPath,dos,params,body,cookie);    //웹 url에 따라 다른 기능을 수행하기 위함
            }
            else{                                         //없는 경우 기본 페이지인 index.html 페이지를 응답으로 보낸다
                log.debug("defaultPath{}",defaultPath);
                byte[] body = Files.readAllBytes(new File("./webapp"+defaultPath).toPath());
                //post 요청 body 읽기;
                int contentLength=0;            //로그인 쿠키 확인
                while(!line.equals("")){
                    line=br.readLine();
                    if(line.contains("Content-Length")){
                        contentLength = getContentLength(line);
                    }
                }
                String user = IOUtils.readData(br,contentLength);
                //post 요청 body 읽기
                urlFunction(requestPath, dos, user, body,cookie);
            }
```


우선 요청 메시지 헤더를 읽는 코드에서 중복이 많으니 해당 코드들을 HttpResponse 클래스로 분리해보겠다.
서버를 돌리지 않는 상태에서 테스트를 하는 것이므로 Http 메서드 GET 방식 헤더를 가지는 txt 파일과 POST 방식의 헤더를
가지는 txt 파일을 만들어준다

- Http_GET.txt
```
GET /user /create?userID=testcode&password=password&name=name HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: */*
```

- Http_POST.txt
```
POST /user /create HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Accept: */*

userID=testcode&password=password&name=name
```

RequestHandler.java에서 중복 된 부분을 HttpRequest.java로 뽑아낸다면 아래 테스트 코드가 성공적으로 돌아야 한다

- HttpRequestTest.java
```
import org.junit.Test;

public class HttpRequestTest{
    private String testDirectory = "./src/test/resources/";
    @Test
    public void requestGet() throws Exception{
        InputStream in = new FileInputStream(new File(testDirectory+"Http_GET.txt"));
        HttpRequest request = new HttpRequest(in);
        assertEquals("GET",request.getMethod());
        assertEquals("/user/create".request.getPath());
        assertEquals("jeep-alive",request.Header("Connection"));
        assertEquals("testcode",request.getParameter(userId);
    }
    @Test
    public void request_POST() throws Exception{
        InputStream in = new FileInputStream(new File(testDirectory+"Http_POST.txt"));
        HttpRequest request = new HttpRequest(in);
        assertEquals("POST",request.getMethod());
        assertEquals("/user/create",request.getPath());
        assertEquals("keep-alive",request.getHeader("Connection"));
        assertEquals("name",request.getParameter)
    }
}
```
